import {message, warn, fail, danger} from "danger";

export default async () => {

    const pr = danger.github.pr;
    const githubLabels = danger.github.issue.labels;

    // Core Data Model Safety Checks
    const targetReleaseBranch = pr.base.ref.startsWith("release/");
    const modifiedFiles = danger.git.modified_files;
    const changedFiles = modifiedFiles.concat(danger.git.deleted_files).concat(danger.git.created_files);
    const hasModifiedModel = changedFiles.some(path => path.includes(".xcdatamodeld"));
    if (targetReleaseBranch && hasModifiedModel) {
        warn("Core Data: Do not edit an existing Core Data model in a release branch unless it hasn't been released to testers yet. Instead create a new model version and merge back to develop soon.");
    }

    // Podfile should not reference branches.
    // See internal reference: paNNhX-K4-p2.
    //
    // Verify by parsing Podfile.lock because it uses a standard format, unlike Podfile which might be written in different ways.
    //
    const podfileLockContents = await danger.github.utils.fileContents("Podfile.lock");
    const podfileLockYAML = require("js-yaml").safeLoad(podfileLockContents);
    const allPods: any[] = (podfileLockYAML && podfileLockYAML["DEPENDENCIES"]) || [];
    const podsReferencedByBranch: string[] = allPods.reduce(parseBranchPods, []);
    if (podsReferencedByBranch.length > 0) {
        fail(`Podfile: reference to a branch for ${podsReferencedByBranch}`);
    }

    // If changes were made to the release notes, there must also be changes to the AppStoreStrings file.
    const hasModifiedReleaseNotes = modifiedFiles.some(f => f.endsWith("Resources/release_notes.txt"));
    const hasModifiedAppStoreStrings = modifiedFiles.some(f => f.includes("Resources/AppStoreStrings.po"));

    if (hasModifiedReleaseNotes && !hasModifiedAppStoreStrings) {
        warn("The AppStoreStrings.po file must be updated any time changes are made to release notes");
    }

    // Let users know that we're skipping tests on release PRs
    const isReleasePr = (githubLabels.length != 0) && githubLabels.some(label => label.name.includes("Releases"));
    if (isReleasePr) {
        message("This PR has the 'Releases' label: some checks will be skipped.");
    }

    // Changes to Resources/en.lproj/Localizable.strings should only be made on release branches since this file is
    // generated by our scripts
    const hasModifiedStrings = modifiedFiles.some(f => f.endsWith("Resources/en.lproj/Localizable.strings"));
    const isReleaseBranch = pr.head.ref.startsWith("release/");

    if (hasModifiedStrings && !isReleaseBranch && !isReleasePr) {
        warn("Localizable.strings should only be updated on release branches because it is generated automatically.");
    }
};

// Function used as a reducer to parse and accumulate pods which are referenced by commit.
// Uses recursion to parse transitive dependencies of each entry.
//
// @param list - The accumulated list of commit-referenced pods so far
// @param entry - an entry representing a pod listed in the lockfile.
//                Will be a `string` if the pod has no dependencies.
//                Otherwise, will be an `object`, with the pod being the single key, and the value being the dependencies
// @return The new list with any commit-referenced pod found added to the initial `list`
function parseCommitPods(list: string[], entry: any): string[] {
    return parsePods(/(.*) \(from .*, commit `.*`/, list, entry);
}

// See documentation for parseCommitPods, but this one finds pods reference by branch instead.
function parseBranchPods(list: string[], entry: any): string[] {
    return parsePods(/(.*) \(from .*, branch `.*`/, list, entry);
}

// Function used as a reducer to parse and accumulate pods from Podfile.lock that match a given RegExp.
// Uses recursion to parse transitive dependencies of each entry.
//
// @param list - The accumulated list of pods matching the condition RegExp so far
// @param entry - an entry representing a pod listed in the lockfile.
//                Will be a `string` if the pod has no dependencies.
//                Otherwise, will be an `object`, with the pod being the single key, and the value being the dependencies
// @return The new list with any matching pod found added to the initial `list`
function parsePods(regexp: RegExp, list: string[], entry: any): string[] {
    if (typeof entry === 'string') {
        const match = entry.match(regexp);
        if (match != null) { list.push(match[1]) };
    } else {
        const key: string = Object.keys(entry)[0];
        list = [key, ...entry[key]].reduce((accumulator, current) => {
            return parsePods(regexp, accumulator, current);
        }, list);
    }
    return list
}
